import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from PIL import Image, ImageTk
from datetime import datetime
from pathlib import Path
import pandas as pd
import subprocess
import sys
import random
import json
import os
import platform
import matplotlib

matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure


BASE_DIR = Path(__file__).resolve().parent
SETTINGS_PATH = BASE_DIR / "settings.json"


# -------------------------
# Helpers (yours, unchanged)
# -------------------------
def _safe_load_image(path, size=(300, 300)):
    try:
        img = Image.open(path)
        img = img.resize(size)
        return ImageTk.PhotoImage(img)
    except Exception:
        return None


def _load_settings():
    if SETTINGS_PATH.exists():
        try:
            with open(SETTINGS_PATH, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return {}
    return {}


def _save_settings(settings: dict):
    try:
        with open(SETTINGS_PATH, "w", encoding="utf-8") as f:
            json.dump(settings, f, indent=2)
    except Exception:
        pass


def _open_folder(path: Path):
    try:
        path = path.resolve()
        if platform.system() == "Windows":
            os.startfile(str(path))  # type: ignore[attr-defined]
        elif platform.system() == "Darwin":
            subprocess.run(["open", str(path)], check=False)
        else:
            subprocess.run(["xdg-open", str(path)], check=False)
    except Exception:
        messagebox.showerror("Error", f"Couldn't open folder:\n{path}")


def _create_or_get_excel(path: Path, batch_str: str):
    path.parent.mkdir(parents=True, exist_ok=True)
    if path.exists():
        return path

    df = pd.DataFrame(columns=["Timestamp", "Batch", "Value"])
    df.loc[0] = [datetime.now().isoformat(sep=" ", timespec="seconds"), batch_str, ""]
    df.to_excel(path, index=False)
    return path


def _read_excel_df(path: Path) -> pd.DataFrame:
    expected = ["Timestamp", "Batch", "Value"]
    try:
        df = pd.read_excel(path)
    except Exception:
        return pd.DataFrame(columns=expected)

    if "Timestamp" not in df.columns and "Date Timestamp" in df.columns:
        df["Timestamp"] = df["Date Timestamp"]
    if "Timestamp" not in df.columns and "Date" in df.columns:
        df["Timestamp"] = df["Date"].astype(str)

    for c in expected:
        if c not in df.columns:
            df[c] = ""

    df = df[expected]
    return df


def _append_to_excel(path: Path, batch_str: str, value):
    df = _read_excel_df(path)

    new_row = pd.DataFrame([{
        "Timestamp": datetime.now().isoformat(sep=" ", timespec="seconds"),
        "Batch": batch_str,
        "Value": value
    }])

    df = pd.concat([df, new_row], ignore_index=True)
    df.to_excel(path, index=False)


def _get_scan_value():
    scan_script = BASE_DIR / "scan_program.py"
    if scan_script.exists():
        try:
            proc = subprocess.run(
                [sys.executable, str(scan_script)],
                capture_output=True,
                text=True,
                check=True,
                timeout=10
            )
            out = proc.stdout.strip() or proc.stderr.strip()
            try:
                if "." in out:
                    return float(out)
                return int(out)
            except Exception:
                return out
        except Exception:
            pass

    exec_path = BASE_DIR / "scan_program.exe"
    if exec_path.exists():
        try:
            proc = subprocess.run(
                [str(exec_path)],
                capture_output=True,
                text=True,
                check=True,
                timeout=10
            )
            out = proc.stdout.strip() or proc.stderr.strip()
            try:
                if "." in out:
                    return float(out)
                return int(out)
            except Exception:
                return out
        except Exception:
            pass

    return random.randint(1, 999)


def _infer_batch_str_from_file(batch_file: Path) -> str:
    batch_str = None
    try:
        df = pd.read_excel(batch_file)
        if not df.empty and "Batch" in df.columns and pd.notna(df.loc[0, "Batch"]):
            batch_str = str(df.loc[0, "Batch"])
    except Exception:
        pass

    if not batch_str:
        parts = batch_file.stem.split("_")
        if len(parts) >= 2 and parts[0].lower() == "batch":
            batch_str = parts[1]

    return batch_str or "?"


# -------------------------
# App Router (single Tk root)
# -------------------------
class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Exuvia Counting Program")
        self.geometry("1400x800")

        settings = _load_settings()
        batches_dir = Path(settings["batches_dir"]) if settings.get("batches_dir") else None

        self.state = {
            "batches_dir": batches_dir,          # Path | None
            "scan_batch_file": None,             # Path | None
            "scan_batch_str": None,              # str | None
            "compare_files": [],                 # list[Path]
        }

        container = tk.Frame(self)
        container.pack(fill=tk.BOTH, expand=True)
        container.rowconfigure(0, weight=1)
        container.columnconfigure(0, weight=1)

        self.pages = {}
        for PageCls in (HomePage, ScanPage, ComparePage):
            page = PageCls(container, self)
            self.pages[PageCls.__name__] = page
            page.grid(row=0, column=0, sticky="nsew")

        self.show("HomePage")

    def show(self, page_name: str):
        page = self.pages[page_name]
        if hasattr(page, "on_show"):
            page.on_show()
        page.tkraise()

    def ensure_batches_dir(self, parent_widget=None) -> bool:
        bd = self.state.get("batches_dir")
        if bd and Path(bd).exists():
            return True

        chosen = filedialog.askdirectory(title="Select folder to save batches in", parent=parent_widget or self)
        if not chosen:
            return False

        bd = Path(chosen)
        bd.mkdir(parents=True, exist_ok=True)
        self.state["batches_dir"] = bd

        settings = _load_settings()
        settings["batches_dir"] = str(bd)
        _save_settings(settings)
        return True


# -------------------------
# Page 1: Home
# -------------------------
class HomePage(tk.Frame):
    def __init__(self, parent, controller: App):
        super().__init__(parent)
        self.controller = controller

        photo = _safe_load_image(BASE_DIR / "oksir.png")
        if photo:
            img_label = tk.Label(self, image=photo, bg="lightgray")
            img_label.image = photo
        else:
            img_label = tk.Label(self, text="[Logo placeholder]", bg="lightgray", font=("Segoe UI", 14))
        img_label.pack(pady=(15, 5))

        tk.Label(self, text="Exuvia Counting Program", font=("Georgia", 18, "bold")).pack(pady=(0, 20))

        btn_frame = tk.Frame(self)
        btn_frame.pack(pady=20)

        tk.Button(btn_frame, text="NEW BATCH", width=16,
                  command=self.new_batch_flow, bg="Grey", fg="white", font=("Arial", 12)
                  ).grid(row=0, column=0, padx=10)

        tk.Button(btn_frame, text="EXISTING BATCH", width=16,
                  command=self.select_existing_batch, bg="Grey", fg="white", font=("Arial", 12)
                  ).grid(row=0, column=1, padx=10)

        tk.Button(btn_frame, text="COMPARE", width=16,
                  command=self.compare_batches_flow, bg="Grey", fg="white", font=("Arial", 12)
                  ).grid(row=0, column=2, padx=10)

    def _ask_batch_number_dialog(self) -> str | None:
        dlg = tk.Toplevel(self)
        dlg.title("New Batch")
        dlg.geometry("320x140")
        dlg.transient(self.controller)
        dlg.grab_set()

        tk.Label(dlg, text="Enter Batch Number:", font=("Segoe UI", 11)).pack(pady=(15, 5))
        entry = tk.Entry(dlg, font=("Segoe UI", 11))
        entry.pack(pady=5)
        entry.focus_set()

        result = {"val": None}

        def ok():
            val = entry.get().strip()
            if not val:
                messagebox.showwarning("Missing batch number", "Please enter a batch number.", parent=dlg)
                return
            result["val"] = val
            dlg.destroy()

        tk.Button(dlg, text="OK", command=ok, width=10).pack(pady=10)
        dlg.wait_window()
        return result["val"]

    def new_batch_flow(self):
        if not self.controller.ensure_batches_dir(self):
            messagebox.showwarning("Missing folder", "Please select a folder to save batches in.", parent=self)
            return

        batch_val = self._ask_batch_number_dialog()
        if not batch_val:
            return

        bd: Path = self.controller.state["batches_dir"]
        file_path = bd / f"batch_{batch_val}.xlsx"
        _create_or_get_excel(file_path, batch_val)

        self.controller.state["scan_batch_file"] = file_path
        self.controller.state["scan_batch_str"] = batch_val
        self.controller.show("ScanPage")

    def select_existing_batch(self):
        if not self.controller.ensure_batches_dir(self):
            return

        bd: Path = self.controller.state["batches_dir"]
        file_path = filedialog.askopenfilename(
            title="Select an existing batch Excel file",
            initialdir=str(bd),
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        if not file_path:
            return

        batch_file = Path(file_path)
        batch_str = _infer_batch_str_from_file(batch_file)

        self.controller.state["scan_batch_file"] = batch_file
        self.controller.state["scan_batch_str"] = batch_str
        self.controller.show("ScanPage")

    def compare_batches_flow(self):
        if not self.controller.ensure_batches_dir(self):
            messagebox.showwarning("Missing folder", "Please select a folder that contains batch files.", parent=self)
            return

        bd: Path = self.controller.state["batches_dir"]
        files = filedialog.askopenfilenames(
            title="Select two or more batch Excel files to compare",
            initialdir=str(bd),
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        if not files:
            return
        if len(files) < 2:
            messagebox.showwarning("Select at least two", "Please select two or more batch files to compare.", parent=self)
            return

        self.controller.state["compare_files"] = [Path(f) for f in files]
        self.controller.show("ComparePage")


# -------------------------
# Page 2: Scan (former open_scan_window)
# -------------------------
class ScanPage(tk.Frame):
    def __init__(self, parent, controller: App):
        super().__init__(parent)
        self.controller = controller

        # Top bar
        top = tk.Frame(self)
        top.pack(fill=tk.X, padx=10, pady=10)

        tk.Button(top, text="← Back", command=lambda: controller.show("HomePage")).pack(side=tk.LEFT)
        self.header = tk.Label(top, text="Scanning", font=("Segoe UI", 14, "bold"))
        self.header.pack(side=tk.LEFT, padx=10)

        self.status_label = tk.Label(self, text="Ready", anchor="w")
        self.status_label.pack(fill=tk.X, padx=10, pady=(0, 8))

        # Layout
        outer = tk.Frame(self)
        outer.pack(fill=tk.BOTH, expand=True)

        outer.columnconfigure(0, weight=4)
        outer.columnconfigure(1, weight=1)
        outer.rowconfigure(0, weight=1)

        self.left = tk.Frame(outer)
        self.left.grid(row=0, column=0, sticky="nsew", padx=(10, 5), pady=10)

        self.right = tk.Frame(outer)
        self.right.grid(row=0, column=1, sticky="nsew", padx=(5, 10), pady=10)

        self.video_label = tk.Label(self.left, text="[Live Video Feed Placeholder]", bg="black", fg="white")
        self.video_label.pack(fill=tk.BOTH, expand=True)

        # Table
        tk.Label(self.right, text="Batch Data", font=("Segoe UI", 12, "bold")).pack(anchor="w")
        table_frame = tk.Frame(self.right)
        table_frame.pack(fill=tk.BOTH, expand=True, pady=(5, 10))

        columns = ("Row", "Timestamp", "Batch", "Value")
        self.tree = ttk.Treeview(table_frame, columns=columns, show="headings", height=12)

        widths = {"Row": 55, "Timestamp": 220, "Batch": 90, "Value": 90}
        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=widths[col], anchor="w")

        vsb = ttk.Scrollbar(table_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=vsb.set)
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        vsb.pack(side=tk.RIGHT, fill=tk.Y)

        # Plot
        tk.Label(self.right, text="Scan Values", font=("Segoe UI", 12, "bold")).pack(anchor="w", pady=(0, 5))

        self.fig = Figure(figsize=(5.2, 3.5), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.ax.set_xlabel("Scan #")
        self.ax.set_ylabel("Value")

        self.canvas = FigureCanvasTkAgg(self.fig, master=self.right)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=False)

        # Buttons
        btn_row = tk.Frame(self.left)
        btn_row.pack(fill=tk.X, pady=(10, 0))

        tk.Button(btn_row, text="SCAN", command=self.do_scan, bg="green", fg="white",
                  font=("Arial", 12), width=12).pack(side=tk.LEFT)
        tk.Button(btn_row, text="DELETE SELECTED", command=self.delete_selected, width=16).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_row, text="SAVE", command=self.save_changes, width=10).pack(side=tk.LEFT)
        tk.Button(btn_row, text="Reload", command=self.reload_from_disk, width=10).pack(side=tk.LEFT, padx=10)
        tk.Button(btn_row, text="Open Excel Folder",
                  command=self.open_excel_folder, width=16).pack(side=tk.LEFT)

        # page state
        self.batch_file: Path | None = None
        self.batch_str: str | None = None
        self.df_cache = pd.DataFrame(columns=["Timestamp", "Batch", "Value"])
        self.dirty = False

    def on_show(self):
        self.batch_file = self.controller.state.get("scan_batch_file")
        self.batch_str = self.controller.state.get("scan_batch_str")

        if not self.batch_file:
            self.status_label.config(text="No batch selected.")
            return

        self.df_cache = _read_excel_df(self.batch_file)
        self.dirty = False
        self.status_label.config(text=f"Ready • File: {self.batch_file.name}")
        self.refresh_table_and_plot()

    def _set_status(self, msg: str):
        suffix = " • Unsaved changes" if self.dirty else ""
        self.status_label.config(text=msg + suffix)

    def _write_df_to_excel(self) -> bool:
        if not self.batch_file:
            return False
        try:
            self.df_cache.to_excel(self.batch_file, index=False)
            self.dirty = False
            self._set_status(f"Saved • File: {self.batch_file.name}")
            return True
        except Exception as e:
            messagebox.showerror("Save Error", f"Could not save Excel file:\n{e}", parent=self)
            return False

    def refresh_table_and_plot(self):
        # Table
        for item in self.tree.get_children():
            self.tree.delete(item)

        for i, row in self.df_cache.iterrows():
            self.tree.insert("", tk.END, values=(i + 1, row.get("Timestamp", ""), row.get("Batch", ""), row.get("Value", "")))

        children = self.tree.get_children()
        if children:
            self.tree.see(children[-1])

        # Plot
        vals = pd.to_numeric(self.df_cache["Value"], errors="coerce").dropna().tolist()

        self.ax.clear()
        self.ax.set_xlabel("Scan #")
        self.ax.set_ylabel("Value")

        if vals:
            x = list(range(1, len(vals) + 1))
            self.ax.plot(x, vals, marker="o")
            self.ax.set_xlim(1, max(2, len(vals)))
        else:
            self.ax.text(0.5, 0.5, "No numeric scan values yet", ha="center", va="center", transform=self.ax.transAxes)

        self.ax.grid(True, linewidth=0.5, alpha=0.4)
        self.fig.tight_layout()
        self.canvas.draw()

    def do_scan(self):
        if not self.batch_file or not self.batch_str:
            messagebox.showwarning("No batch", "No batch is loaded.", parent=self)
            return

        self._set_status("Scanning...")
        scan_val = _get_scan_value()

        self.df_cache.loc[len(self.df_cache)] = [
            datetime.now().isoformat(sep=" ", timespec="seconds"),
            self.batch_str,
            scan_val
        ]

        ok = self._write_df_to_excel()
        if ok:
            self.status_label.config(text=f"Last scan: {scan_val} at {datetime.now().strftime('%H:%M:%S')} • Saved • File: {self.batch_file.name}")

        self.refresh_table_and_plot()

    def delete_selected(self):
        sel = self.tree.selection()
        if not sel:
            messagebox.showwarning("No selection", "Select a scan row to delete.", parent=self)
            return

        vals = self.tree.item(sel[0], "values")
        if not vals:
            return

        try:
            row_num = int(vals[0])  # 1-based
        except Exception:
            messagebox.showerror("Delete Error", "Could not determine selected row number.", parent=self)
            return

        idx = row_num - 1
        if idx < 0 or idx >= len(self.df_cache):
            messagebox.showerror("Delete Error", "Selected row is out of range.", parent=self)
            return

        self.df_cache.drop(index=idx, inplace=True)
        self.df_cache.reset_index(drop=True, inplace=True)
        self.dirty = True

        if self.batch_file:
            self._set_status(f"Deleted row {row_num} • File: {self.batch_file.name}")
        self.refresh_table_and_plot()

    def save_changes(self):
        if not self.batch_file:
            return
        if not self.dirty:
            self._set_status("No unsaved changes • File: " + self.batch_file.name)
            return
        self._write_df_to_excel()
        self.refresh_table_and_plot()

    def reload_from_disk(self):
        if not self.batch_file:
            return
        self.df_cache = _read_excel_df(self.batch_file)
        self.dirty = False
        self._set_status(f"Reloaded • File: {self.batch_file.name}")
        self.refresh_table_and_plot()

    def open_excel_folder(self):
        if not self.batch_file:
            return
        _open_folder(self.batch_file.parent)


# -------------------------
# Page 3: Compare (former open_compare_window)
# -------------------------
class ComparePage(tk.Frame):
    def __init__(self, parent, controller: App):
        super().__init__(parent)
        self.controller = controller

        top = tk.Frame(self)
        top.pack(fill=tk.X, padx=10, pady=10)

        tk.Button(top, text="← Back", command=lambda: controller.show("HomePage")).pack(side=tk.LEFT)
        tk.Label(top, text="Compare Batches", font=("Segoe UI", 14, "bold")).pack(side=tk.LEFT, padx=10)

        outer = tk.Frame(self)
        outer.pack(fill=tk.BOTH, expand=True)

        outer.columnconfigure(0, weight=2)
        outer.columnconfigure(1, weight=3)
        outer.rowconfigure(0, weight=1)

        self.left = tk.Frame(outer)
        self.left.grid(row=0, column=0, sticky="nsew", padx=(10, 5), pady=10)

        self.right = tk.Frame(outer)
        self.right.grid(row=0, column=1, sticky="nsew", padx=(5, 10), pady=10)

        tk.Label(self.left, text="Selected Batches", font=("Segoe UI", 12, "bold")).pack(anchor="w")
        self.listbox = tk.Listbox(self.left, height=5)
        self.listbox.pack(fill=tk.X, pady=(5, 10))

        self.avg_frame = tk.LabelFrame(self.left, text="Averages", padx=8, pady=8)
        self.avg_frame.pack(fill=tk.X, pady=(0, 10))

        self.avg_batch_label = tk.Label(self.avg_frame, text="Per-batch averages will appear here.", justify="left", anchor="w")
        self.avg_batch_label.pack(fill=tk.X)

        self.avg_combined_label = tk.Label(self.avg_frame, text="Combined average: —", justify="left", anchor="w")
        self.avg_combined_label.pack(fill=tk.X, pady=(6, 0))

        tk.Label(self.left, text="Data (per batch)", font=("Segoe UI", 12, "bold")).pack(anchor="w")
        self.notebook = ttk.Notebook(self.left)
        self.notebook.pack(fill=tk.BOTH, expand=True, pady=(5, 0))

        tk.Label(self.right, text="Comparison Plot", font=("Segoe UI", 12, "bold")).pack(anchor="w")
        self.fig = Figure(figsize=(6.8, 5.8), dpi=100)
        self.ax = self.fig.add_subplot(111)
        self.ax.set_xlabel("Scan #")
        self.ax.set_ylabel("Value")

        self.canvas = FigureCanvasTkAgg(self.fig, master=self.right)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True, pady=(5, 0))

        btn_row = tk.Frame(self.right)
        btn_row.pack(fill=tk.X, pady=(10, 0))

        tk.Button(btn_row, text="Refresh", command=self.load_all, width=10).pack(side=tk.LEFT)
        tk.Button(btn_row, text="Open Folder", command=self.open_folder, width=12).pack(side=tk.LEFT, padx=10)

        # runtime structures
        self.batch_files: list[Path] = []
        self.tab_tables: dict[Path, ttk.Treeview] = {}

    def on_show(self):
        self.batch_files = self.controller.state.get("compare_files", []) or []
        self.rebuild_tabs()
        self.load_all()

    def _make_table(self, parent_frame):
        cols = ("Timestamp", "Batch", "Value")
        table_frame = tk.Frame(parent_frame)
        table_frame.pack(fill=tk.BOTH, expand=True)

        tree = ttk.Treeview(table_frame, columns=cols, show="headings")
        tree.heading("Timestamp", text="Timestamp")
        tree.heading("Batch", text="Batch")
        tree.heading("Value", text="Value")

        tree.column("Timestamp", width=210, anchor="w")
        tree.column("Batch", width=90, anchor="w")
        tree.column("Value", width=90, anchor="w")

        vsb = ttk.Scrollbar(table_frame, orient="vertical", command=tree.yview)
        tree.configure(yscrollcommand=vsb.set)

        tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        vsb.pack(side=tk.RIGHT, fill=tk.Y)
        return tree

    def rebuild_tabs(self):
        # listbox
        self.listbox.delete(0, tk.END)
        for f in self.batch_files:
            b = _infer_batch_str_from_file(f)
            self.listbox.insert(tk.END, f"{b}  •  {f.name}")

        # clear tabs
        for tab_id in self.notebook.tabs():
            self.notebook.forget(tab_id)

        self.tab_tables.clear()

        # rebuild tabs
        for f in self.batch_files:
            b = _infer_batch_str_from_file(f)
            tab = tk.Frame(self.notebook)
            self.notebook.add(tab, text=b)
            self.tab_tables[f] = self._make_table(tab)

    def load_all(self):
        self.ax.clear()
        self.ax.set_xlabel("Scan #")
        self.ax.set_ylabel("Value")

        # clear tables
        for tree in self.tab_tables.values():
            for item in tree.get_children():
                tree.delete(item)

        any_series = False
        pooled_vals: list[float] = []
        avg_map: dict[str, float] = {}

        for f in self.batch_files:
            df = _read_excel_df(f).copy()
            batch_label = _infer_batch_str_from_file(f)

            # Fill tab table
            tree = self.tab_tables.get(f)
            if tree:
                for _, r in df.iterrows():
                    tree.insert("", tk.END, values=(r.get("Timestamp", ""), r.get("Batch", ""), r.get("Value", "")))
                children = tree.get_children()
                if children:
                    tree.see(children[-1])

            vals = pd.to_numeric(df["Value"], errors="coerce").dropna().tolist()
            if vals:
                pooled_vals.extend(vals)
                avg_map[batch_label] = float(sum(vals) / len(vals))

                x = list(range(1, len(vals) + 1))
                self.ax.plot(x, vals, marker="o", label=batch_label)
                any_series = True

        # Averages
        lines = []
        for f in self.batch_files:
            b = _infer_batch_str_from_file(f)
            if b in avg_map:
                lines.append(f"{b}: {avg_map[b]:.3f}")
            else:
                lines.append(f"{b}: —")
        self.avg_batch_label.config(text="\n".join(lines))

        if pooled_vals:
            combined_avg = float(sum(pooled_vals) / len(pooled_vals))
            self.avg_combined_label.config(text=f"Combined average (all batches): {combined_avg:.3f}")
        else:
            self.avg_combined_label.config(text="Combined average (all batches): —")

        if any_series:
            self.ax.legend()
        else:
            self.ax.text(0.5, 0.5, "No numeric scan values found in selected files",
                         ha="center", va="center", transform=self.ax.transAxes)

        self.ax.grid(True, linewidth=0.5, alpha=0.4)
        self.fig.tight_layout()
        self.canvas.draw()

    def open_folder(self):
        if not self.batch_files:
            return
        _open_folder(self.batch_files[0].parent)


# -------------------------
# Run
# -------------------------
if __name__ == "__main__":
    app = App()
    app.mainloop()
